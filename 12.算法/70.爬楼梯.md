# LeetCode 👉 HOT 100 👉 不同路径 - 简单题

## 题目

假设你正在爬楼梯。需要 n 阶你才能到达楼顶。

每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？

注意：给定 n 是一个正整数。

**示例1**

    输入： 2

    输出： 2

    解释： 有两种方法可以爬到楼顶。

    1.  1 阶 + 1 阶
    2.  2 阶

**示例2**

    输入： 3

    输出： 3

    解释： 有三种方法可以爬到楼顶。

    1.  1 阶 + 1 阶 + 1 阶
    2.  1 阶 + 2 阶
    3.  2 阶 + 1 阶

## 思路

这道题是很经典的 `动态规划` 类型题目（**为啥？做的多了，题感就来了**）。

而这类型题目都是有固定套路的，那么回顾一下动态规划的几个基本步骤：

- 定义 `dp` 数组元素的含义

- 确定数组元素间的关系式

- 确定边界、初始条件

对于本道算法题，`dp` 数组元素的含义，可以定义为 `dp[i]` 为走到第 `i` 个台阶，共有 `dp[i]` 种方法；而想要确定元素间的关系式，可以做如下思考，想要到达第 `i` 个台阶，因为题目规定一次只能爬 `1 | 2` 个台阶，那么对于第 `i` 个台阶，只能从第 `i - 1` 个台阶爬 `1` 个楼梯到达第 `i` 个台阶，或者从第 `i - 2` 个台阶开始，爬 `2` 个台阶到达第 `i` 个台阶。因为题目所求为并集，所以可以得出元素间的关系式为 `dp[i] = dp[i - 1] + dp[i - 2]`；上述关系式中，很明显 `i 需满足 i >= 2`，那么动态规划的 初始条件就有 `dp[0] = 1`（**只有1个台阶，只能有一个方法到达**），`dp[1] = 2`（**两个台阶，可以选择一个一个走，或者一次爬两个，所以两种方法到达**）；边界条件自然就是 `i < n`;

**代码如下**

```js
    /**
     * @param {number} n
     * @return {number}
     */
    var climbStairs = function (n) {
        // 初始化dp
        const dp = new Array(n).fill(0);

        // 初始条件
        dp[0] = 1;
        dp[1] = 2;

        for (let i = 2; i < n; i++) {
            // 元素间关系式
            dp[i] = dp[i - 1] + dp[i - 2];
        }

        // dp[n - 1] 为所求
        return dp[n - 1];
    };
```

## 小结

动态规划是一个具有固定套路的解法，如果能够判断出题目可以使用动态规划去解决，那么只要寻找几个要素，基本可以解决问题。

关于如何看出题目适用何种解法，多做题就好了，题感自然就会来～


[# LeetCode 👉 HOT 100 👉 不同路径 - 中等题](https://leetcode-cn.com/problems/climbing-stairs/) ✅


[合集：LeetCode 👉 HOT 100](https://juejin.cn/column/7029946677398077476)，有空就会更新，大家多多支持，点个赞👍

如果大家有好的解法，或者发现本文理解不对的地方，欢迎留言评论 😄

