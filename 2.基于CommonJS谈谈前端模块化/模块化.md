# 模块化

`CMJ` 被熟知得益于 `Node` 社区的炸裂兴起，不过目前 `Node` 已经转移向了 `ESM`。不过有兴趣的依然可以研究研究，`Node` 中的 `CMJ` 实现 [`Node` 中 `CMJ` 实现源代码](https://github1s.com/nodejs/node/blob/HEAD/lib/internal/modules/cjs/loader.js)

1、模块化如何划分？

不管是 `CMJ` 还是 `ESM`，都不约而同的选择了以「文件」为基本单位来划分模块。

文件是组织代码结构的基本单位，在模块加载器自身的处理上来说，也是一个相对来说更容易的粒度～

2、如何使用？

```js
// a.js
exports.action = function () {
  console.log('Action!');
}

// b.js
const a = require('./a.js');

a.action();
```

其实模块机制也是在设计 `API`，在设计层面，要注重考虑简洁、易用，`CMJ` 统一使用 `require` 关键字来引入模块，暴露模块的方式是挂载到 `exports` 对象引用上（当然也可以重写这个对象引用），这样的设计使得用户使用、学习起来没有过多的心智负担，想想一个模块加载器暴露给你的基本 `API` 就有十几个，你会觉得好用吗？

3、同步还是异步？

这也是设计之初就需要考虑到的问题，对模块的加载解析过程如果是异步，那必然和同步的处理方式有极大的区别，`CMJ` 是 之所以被 `Node` 采用，也是因为其设计之初考虑的就不是浏览器层面的，更偏向 `Server`, `Node` 本身在 `IO` 上就有足够的底气和实力，同步的方式契合了需求，只是目前推崇的 `ESM` 是官方的，未来的，`Node` 必须妥协于大流。

CommonJS不适用于浏览器端，因为它是同步的，对于浏览器不友好。